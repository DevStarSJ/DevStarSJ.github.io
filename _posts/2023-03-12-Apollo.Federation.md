---
layout: post
title: "Apollo Federation: MSA for GraphQL"
subtitle:  
categories: development
tags: devops
comments: true
---

## 1. What is Apollo Federation?

Apollo Federationì€ ì—¬ëŸ¬ ê°œì˜ ì„œë¹„ìŠ¤ê°€ í•˜ë‚˜ì˜ ê·¸ë˜í”„ APIë¥¼ êµ¬ì„±í•˜ê³ , ì´ë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì‰½ê²Œ ë°ì´í„°ë¥¼ ê²€ìƒ‰í•˜ê³  ì¡°ì‘í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ë¥¼ ì§€ì›í•˜ëŠ” Apollo GraphQLì˜ ê¸°ëŠ¥ ì¤‘ í•˜ë‚˜ì´ë‹¤.

Apollo Federation is one of the features of Apollo GraphQL that supports a microservice architecture that allows multiple services to construct a single graph API, which makes it easy to retrieve and manipulate data in client applications.

Netflixì—ì„œ Apollo Federationì„ ì´ìš©í•´ì„œ ì„œë¹„ìŠ¤ ë³‘ëª©ì§€ì ì´ ë˜ëŠ” ê±°ëŒ€í•œ GraphQL ì„œë¹„ìŠ¤ë¥¼ ê° ì¡°ì§ë³„ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” í˜•íƒœë¡œ ì „í™˜í•˜ëŠ”ë° ì„±ê³µí•˜ì˜€ë‹¤. ì´ ë‚´ìš©ì— ëŒ€í•´ì„œëŠ” Youtube ë° Netflix ê¸°ìˆ ë¸”ë¡œê·¸ì— ìì„¸íˆ ì•ˆë‚´ë˜ì–´ ìˆë‹¤.

Netflix succeeded in using Apollo Federation to transform the huge GraphQL service, which becomes a service bottleneck, into a form that can be managed by each organization. This content is detailed in the YouTube and Netflix technology blogs.

- [https://youtu.be/QrEOvHdH2Cg](https://youtu.be/QrEOvHdH2Cg)
- [https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2](https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2)
- [https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-2-bbe71aaec44a](https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-2-bbe71aaec44a)

## 2. Advantages of Apollo Federation

1. ë³µì¡í•œ ë°ì´í„° ëª¨ë¸ë§: Apollo Federationì€ ê° ì„œë¹„ìŠ¤ë¥¼ ë…ë¦½ì ìœ¼ë¡œ ê°œë°œí•˜ê³  ë°°í¬í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•˜ë©°, ì´ë¥¼ í†µí•´ ì„œë¹„ìŠ¤ë¥¼ ë” ì‘ê³  ë‹¨ìˆœí•˜ê²Œ ìœ ì§€í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, ì—¬ëŸ¬ ì„œë¹„ìŠ¤ ê°„ì— ê³µìœ ë˜ëŠ” ë°ì´í„° ëª¨ë¸ì„ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë³µì¡í•œ ë°ì´í„° ëª¨ë¸ë§ì´ ê°€ëŠ¥í•˜ë‹¤.
2. í™•ì¥ì„±: Apollo Federationì€ ìˆ˜í‰ì ìœ¼ë¡œ í™•ì¥í•  ìˆ˜ ìˆëŠ” ì•„í‚¤í…ì²˜ë¥¼ ì§€ì›í•œë‹¤. ìƒˆë¡œìš´ ì„œë¹„ìŠ¤ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ê¸°ì¡´ ì„œë¹„ìŠ¤ë¥¼ ìˆ˜ì •í•˜ë”ë¼ë„ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ì— ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•Šìœ¼ë¯€ë¡œ, ì„œë¹„ìŠ¤ë¥¼ ì‰½ê²Œ í™•ì¥í•  ìˆ˜ ìˆë‹¤.
3. ìœ ì—°ì„±: Apollo Federationì€ ì—¬ëŸ¬ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì™€ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì§€ì›í•˜ë©°, ê¸°ì¡´ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ì™€ ì‰½ê²Œ í†µí•©ë  ìˆ˜ ìˆë‹¤.
4. ì„±ëŠ¥: Apollo Federationì€ ì—¬ëŸ¬ ê°œì˜ ì„œë¹„ìŠ¤ë¥¼ ì‰½ê²Œ ì—°ê²°í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•˜ë©°, ë¶ˆí•„ìš”í•œ ë°ì´í„° ìš”ì²­ì„ ìµœì†Œí™”í•˜ì—¬ ì„±ëŠ¥ì„ ìµœì í™”í•œë‹¤.
5. ê°œë°œ ìƒì‚°ì„±: Apollo Federationì€ GraphQLì˜ ê¸°ëŠ¥ì„ ì œê³µí•˜ë¯€ë¡œ, ê°œë°œìëŠ” ë°ì´í„°ë¥¼ ì‰½ê²Œ ê²€ìƒ‰í•˜ê³  ì¡°ì‘í•  ìˆ˜ ìˆë‹¤. ë˜í•œ, Apollo Studioì™€ ê°™ì€ íˆ´ì„ ì‚¬ìš©í•˜ì—¬ ì‰½ê²Œ APIë¥¼ ë¬¸ì„œí™”í•˜ê³  ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆë‹¤.

Apollo Federationì€ ì—¬ëŸ¬ microservicesë¡œ êµ¬ì„±ëœ GraphQL ì„œë¹„ìŠ¤ë¥¼ ë‹¨ì¼ endpointì—ì„œ í†µí•©í•´ì„œ í•˜ë‚˜ì˜ GraphQLë¡œ ì œê³µí•´ì£¼ëŠ” API Gatewayê°™ì€ ì—­í• ì„ í•´ì¤€ë‹¤.

1. Complex data modeling: Apollo Federation enables each service to be developed and distributed independently, allowing it to be smaller and simpler. In addition, since data models shared between multiple services can be centrally managed, complex data modeling is possible.
2. Scalability: Apollo Federation supports horizontally scalable architectures. Adding new services or modifying existing services does not affect other services, so services can be easily expanded.
3. Flexibility: Apollo Federation supports multiple programming languages and databases, and can be easily integrated with existing microservices architectures.
4. Performance: Apollo Federation makes it easy to connect multiple services and optimizes performance by minimizing unnecessary data requests.
5. Development Productivity: Apollo Federation provides GraphQL capabilities, so developers can easily search and manipulate data. In addition, tools such as Apollo Studio can be used to easily document and monitor APIs.

Apollo Federation acts as an API gateway that integrates GraphQL services consisting of multiple microservices from a single endpoint and provides them as a GraphQL.

## 3. Simple examples of Subgraphs and Gateway

ë¨¼ì € ì•ìœ¼ë¡œ ë“±ì¥í•  ì˜ˆì œì½”ë“œì— ëŒ€í•œ ì„¤ëª…í•˜ê² ë‹¤.

- ëŒ€ë¶€ë¶„ì˜ ê¸°ìˆ ë¸”ë¡œê·¸, Youtube ì˜ìƒë“±ì—ì„œëŠ” express + apollo ê¸°ë°˜ì˜ ì½”ë“œë¡œ ì„¤ëª…ì„ í•˜ê³  ìˆë‹¤.
- í˜„ì¬ Nodeë¡œ ê°œë°œì„ í•˜ëŠ” ë§ì€ ìŠ¤íƒ€íŠ¸ì—… íšŒì‚¬ì—ì„œ Nest.JSë¥¼ í™œìš©í•˜ê³  ìˆìœ¼ë¯€ë¡œ, ì•ìœ¼ë¡œ ì„¤ëª…ì—ì„œ ë‚˜ì˜¤ëŠ” ì†ŒìŠ¤ì½”ë“œë“¤ì€ Nest.JS ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±í•˜ë„ë¡ í•˜ê² ë‹¤.
- `@nestjs/apollo`, `@apollo/subgraph`, `@nestjs/typeorm` ë¥¼ í™œìš©í•œ ì½”ë“œì´ë‹¤.
- `typeorm` ì˜ ê²½ìš° **active record pattern** ìœ¼ë¡œ í‘œí˜„í•œë‹¤.
- Apollo Federation v2ë¥¼ ì‚¬ìš©í–ˆìœ¼ë©°, ê·¸ëŸ¬ê¸° ìœ„í•´ì„œëŠ” Apollo Server v4ê°€ í•„ìš”í•˜ë‹¤.

First, I will explain the example code that will appear in the future.

- Most technical blogs and YouTube videos are explained with express+apollo-based code.
- Currently, many startup companies developing with Node are using Nest.JS, so we will write the source codes in the description based on Nest.JS.
- The code uses `@nestjs/apollo`, `@apollo/subgraph`, and `@nestjs/typeorm`.
- In the case of `typeorm`, it is expressed as **active record pattern**.
- We used Apollo Federation v2, and we need Apollo Server v4.

- Hospital Service Server (http://localhost:4001/graphql)
    - query hospitalsë¥¼ ì œê³µ
        
```tsx
// schema.gql

type Hospital {
  id: ID
  name: String!
}

type Query {
  hospital(id: ID): [Hospital]
}

// hospital.resolver.ts

@Resolver(() => Hospital)
export class HospitalResolver  {
  @Query(() => [Hospital])
  async hospitals(@Args('id', {type: () => ID, , nullable: true}) id?: string) {
    return id ? Hospital.find({where: {id}) : Hospital.find();
  }
}
```
        
- Doctor Service Server (http://localhost:4002/graphql)
    - query doctorsë¥¼ ì œê³µ
        
```tsx
// schema.gql

type Doctor {
  id: ID
  name: String!
}

type Query {
  doctor(id: ID): [Doctor]
}

// doctor.resolver.ts

@Resolver(() => Doctor)
export class DoctorResolver  {
  @Query(() => [Doctor])
  async doctors(@Args('id', {type: () => ID, , nullable: true}) id?: string) {
    return id? Doctor.find({where: {id}) : Doctor.find();
  }
}
```
        

ìœ„ì™€ ê°™ì´ 2ê°œì˜ microserviceê°€ ìš´ì˜ì¤‘ì´ë¼ê³  ê°€ì •í–ˆì„ë•Œ

Assuming that two microservices are in operation as above,

- Apollo Federation Gateway (http://localhost:3000/graphql)
    
```jsx
const { ApolloServer } = require("apollo-server");
const { ApolloGateway, IntrospectAndCompose } = require("@apollo/gateway");

const supergraphSdl = new IntrospectAndCompose({
  subgraphs: [
    { name: "hospital", url: "http://localhost:4001/graphql" },
    { name: "doctor", url: "http://localhost:4002/graphql" },
  ],
});

const gateway = new ApolloGateway({
  supergraphSdl,
  __exposeQueryPlanExperimental: false,
});

(async () => {
  const server = new ApolloServer({
    gateway,
    engine: false,
    subscriptions: false,
  });

  server.listen().then(({ url }) => {
    console.log(`ğŸš€ Server ready at ${url}`);
  });
})();
```
    

ë§Œì•½ headerì˜ **Authorization** ì„ ê° ì„œë¹„ìŠ¤ë¡œ ì „ë‹¬í•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì´ ìˆ˜ì •í•´ì•¼ í•œë‹¤.

If you want to deliver the header's **Authorization** to each service, you need to modify it as follows.

```jsx
const { startStandaloneServer } = require('@apollo/server/standalone');
const { RemoteGraphQLDataSource } = require("@apollo/gateway");

class AuthenticatedDataSource extends RemoteGraphQLDataSource {
  willSendRequest({ request, context }) {
    request.http.headers.set('Authorization', context.authorization);
  }
}

const gateway = new ApolloGateway({
  supergraphSdl,
  buildService({ name, url }) {
    return new AuthenticatedDataSource({ name, url });
  }
});

(async () => {
  const server = new ApolloServer({ gateway });
  const { url } = await startStandaloneServer(server, {
    context: ({ req }) => 
			({ authorization: req.headers.authorization || '' })
  });
  console.log(`ğŸš€  Server ready at ${url}`);
})();
```


Apollo Federationì—ì„œ ìœ„ 2ê°œ serviceë¥¼ subgraphsë¡œ ë¬¶ì–´ì„œ ì‹¤í–‰í•  ê²½ìš° `localhost:3000/graphql` ë¡œ ì ‘ê·¼í•˜ë©´

If Apollo Federation executes the above two services by combining them with subgraphs, access 'localhost:3000/graphql'

- query hospitals
- query doctors

ë¥¼ ëª¨ë‘ ì œê³µí•œë‹¤.


í•˜ì§€ë§Œ ì´ê²ƒë§Œìœ¼ë¡œ GraphQL Schemaë¥¼ mergeí–ˆë‹¤ê³  í•˜ê¸°ì—ëŠ” ë¬´ì–¸ê°€ ë¶€ì¡±í•˜ë‹¤. hospital has many doctos ê´€ê³„ì¼ ê²½ìš° `hospital.doctors` ë˜ëŠ” `doctor.hospital` ê³¼ ê°™ì´ 2ê°œì˜ subgraphë¥¼ í•˜ë‚˜ì˜ queryë¡œ ê°€ì ¸ì˜¤ì§€ ëª»í•œë‹¤ë©´ ì‚¬ìš©í•˜ê¸°ì— í•˜ë‚˜ì˜ GraphQLë¡œ ì„œë¹„ìŠ¤í•˜ëŠ” ê²ƒì— ë¹„í•´ì„œ ë¶ˆí¸í•¨ì´ í¬ë‹¤.

However, this alone is not enough to merge GraphQL Schema. In the case of the hospital has any doctor relationship, if two subgraphs, such as 'hospital.doctors' or 'doctor.hospital', cannot be imported into one query, it is more inconvenient than serving with one GraphQL for use.

## 4. Relationship between Object Types Across Multiple Subgraphs

ê°ê°ì˜ Subgraphì—ì„œ ì œê³µí•˜ëŠ” Object Typeê°„ì˜ relationì„ í™œìš©í•˜ì—¬ í•˜ë‚˜ì˜ queryì—ì„œ ì‹¤í–‰í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•Ÿ. ê·¸ë ‡ê²Œí•˜ê¸° ìœ„í•´ì„œëŠ” GraphQLì˜ ì§€ì‹œì–´(directive)ë¥¼ í™œìš©í•´ì•¼ í•œë‹¤.

It is also possible to execute in one query by utilizing the relation between object types provided by each subgraph. To do so, GraphQL's directives must be used.

ì‚¬ìš©ê°€ëŠ¥í•œ directivesëŠ” ì•„ë˜ì—ì„œ í™•ì¸ì´ ê°€ëŠ¥í•˜ë‹¤.

Available directives can be found below.

- [https://www.apollographql.com/docs/federation/federated-types/federated-directives](https://www.apollographql.com/docs/federation/federated-types/federated-directives)

Subgraphë¥¼ ë„˜ì–´ì„  Object Typeê°„ì˜ relationì€ ì•„ë˜ì™€ ê°™ì´ ì„ ì–¸ì´ ê°€ëŠ¥í•˜ë‹¤.

The relationship between object types beyond the subgraph can be declared as follows.

- Doctor Service Server (http://localhost:4002/graphql)
    
```jsx
type Doctor {
  id: ID
  name: String!
  hospital: Hospital
}

extend type Hospital @key(fields: "id") {
  id: ID! @external
  doctors: [Doctor]
}
```
    
- Hospital Service Server (http://localhost:4001/graphql)
    
```jsx
type Hospital @key(fields: "id") {
  id: ID
  name: String!
}
```
    

ê·¸ëŸ° ë‹¤ìŒ Doctor Service Serverì—ì„œ HospitalResolverë¥¼ êµ¬í˜„í•´ì£¼ë©´ ëœë‹¤.

Then, implement HospitalResolver on the Doctor Service Server.

```jsx
@Resolver(() => Hospital)
export class HospitalResolver extends HospitalBaseResolver {
  @ResolveField(() => [Doctor], {nullable: 'itemsAndList', defaultValue: []})
  doctors(@Parent() hospital: Hospital, @Context() context: any) {
    return Doctor.find({where: {hospitalId: hospital.id});
  }
}
```

í•˜ì§€ë§Œ ìœ„ êµ¬í˜„ì€ N+1 ì¿¼ë¦¬ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤. DataLoaderë¥¼ ì´ìš©í•´ì„œ ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ë ¤ë©´ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„í•´ì•¼ í•œë‹¤.

However, in the above implementation, an N+1 query may occur. To solve this problem using Data Loader, it should be implemented as follows.

```jsx
export function hospitalDoctorLoader() {
  return new DataLoader<string, Doctor[]>(
    async (hospitalIds: readonly string[]) => {
      const doctors = await Doctor.find({where: {hospitalId: In([...hospitalIds])}});
      const hospitalDoctorMap = _.groupBy(doctors, row => row.hospitalId);
      return _.map(hospitalIds, hospitalId => hospitalDoctorMap[hospitalId]);
    }, {cache: false});
}

const dataLoaders = {
	hospitalDoctorLoader: hospitalDoctorLoader()
}

// GraphQL Module contextì— dataloader ì‚½ì…

context: ({ extra }) => ({ extra, ...dataLoaders, }),

// hospital.resolver.ts

@Resolver(() => Hospital)
export class HospitalResolver extends HospitalBaseResolver {
  @ResolveField(() => [Doctor], {nullable: 'itemsAndList', defaultValue: []})
  doctors(@Parent() hospital: Hospital, @Context() context: any) {
    return context.hospitalDoctorLoader.load(hospital.id);
  }
}
```

Gatewayë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•œ ë’¤ `[localhost:300/graphql](http://localhost:300/graphql)` ë¡œ ì ‘ì†í•˜ì—¬ `hospital.doctors` ë¥¼ ì¿¼ë¦¬í•´ë³´ì.

After running the gateway again, go to '[localhost:300/graphql](http://localhost:300/graphql)' and query 'hospital.doctors'.

```graphql
query ExampleQuery {
  hospital(id: "id") {
    id
    name
    doctors {
      id
      name		
    }
  }
}
```

ë§Œì•½ 2ê°œì˜ Subgraph ì„œë²„ì— logë¥¼ ì¼œ ë‘ì—ˆë‹¤ë©´ ë¨¼ì € `Hospital Service Server` ì—ì„œ ì´ì „ê³¼ ë™ì¼í•œ queryê°€ ì‹¤í–‰ëœ ë‹¤ìŒ `Doctor Service Server` ê°€ ì‹¤í–‰ë˜ëŠ” ê²ƒì„ í™•ì¸ í•  ìˆ˜ ìˆë‹¤.

If log is turned on for two subgraph servers, it can be verified that 'Hospital Service Server' first executes the same query as before and then 'Doctor Service Server'.

## 5. Precautions for Apollo Federation

Apollo Federationì˜ ì£¼ì˜ì‚¬í•­ ë° ê°ì¢… ì„¤ì •ë°©ë²•ì€ ê³µì‹ë¬¸ì„œì—ì„œ í™•ì¸ì´ ê°€ëŠ¥í•˜ë‹¤. ì§€ê¸ˆê¹Œì§€ ì‘ì—…í•˜ë©´ì„œ ì•Œì•„ë‚¸ ê²ƒì„ ê°„ë‹¨íˆ ì •ë¦¬í•´ë³´ìë©´, 

- Subgraphì— ë™ì¼í•œ Object Typeì´ ì„ ì–¸ë˜ì–´ ìˆìœ¼ë©´ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤. ì´ ê²½ìš° `@shareable` ì´ë¼ëŠ” directiveë¥¼ ë¶™ì—¬ì£¼ëŠ” ê²ƒìœ¼ë¡œ í•´ê²°ì´ ê°€ëŠ¥í•œë°, ì´ê±¸ Object typeì— ì ì–´ì¤„ ìˆ˜ë„ ìˆê³ , ê° fieldì—ë‹¤ê°€ ë¶™ì—¬ì¤„ìˆ˜ë„ ìˆë‹¤. ì—¬ëŸ¬ subgraphì— ì„ ì–¸ëœ `@shareable` í•­ëª©ì´ ë™ì¼í•´ì•¼ì§€ë§Œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.
- ë™ì¼í•œ ì´ë¦„ì˜ query, mutationì´ ì—¬ëŸ¬ subgraphì— ìˆë”ë¼ë„ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤. ë§Œì•½ interfaceê°€ ë™ì¼í•œ query, mutationì´ ì—¬ëŸ¬ê°œ ìˆëŠ” ê²½ìš° ì–´ë–¤ ê²ƒì„ ë” ìš°ì„ ìˆœìœ„ë¥¼ ë‘ì–´ì„œ ì‹¤í–‰í• ì§€ì— ëŒ€í•œ ì„¤ì •ì€ ì—†ë‹¤. í˜„ì¬ ì•Œì•„ë‚¸ ì •ë³´ë¡œëŠ” gatewayì— ì„ ì–¸ëœ subgraph ëŒ€í‘œì´ë¦„ì˜ ABC ìˆœì„œë¡œ ë¨¼ì €ì˜¤ëŠ” ê²ƒì´ ì‹¤í–‰ë˜ì—ˆë‹¤.
- subscription ì€ í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠëŠ”ë‹¤. (2023.03ê¸°ì¤€) í•˜ì§€ë§Œ ì•ìœ¼ë¡œ ì§€ì›í•  ì˜ˆì •ì´ë©°, ì§€ê¸ˆë„ ì´ê±¸ ë™ì‘í•˜ê²Œ í•˜ê¸° ìœ„í•´ì„œ í•´ì•¼í•˜ëŠ” ì‘ì—…ë“¤ì€ ê³µì‹ë¬¸ì„œì— ì†Œê°œë˜ì–´ ìˆë‹¤.

The precautions and various setting methods of Apollo Federation can be checked in the official document. To summarize what we've learned so far,

- If the same Object Type is declared in the subgraph, an error occurs. In this case, it can be solved by attaching a directive called '@shareable', which can be written on the Object type or attached to each field. The '@shareable' items declared in various subgraphs must be the same to prevent errors.
- No error occurs even if the query, mutation of the same name is in multiple subgraphs. If there are multiple query, mutation with the same interface, there is no setting for which to prioritize. As for the information currently obtained, the ABC order of the representative name of the subgraph declared on the gateway was executed first.
- Subscription is not currently supported. (As of 2023.03) However, it will be supported in the future, and the work that needs to be done to make it work is introduced in the official document.

## 6. Conclusion

ì„œë¹„ìŠ¤ ê·œëª¨ê°€ ì»¤ì§€ë©´ì„œ í•˜ë‚˜ì˜ í° GraphQL ì„œë¹„ìŠ¤ë¡œ ì‘ì—…í•˜ê¸°ì— ì–´ë ¤ìš´ ì‹œì ì´ ì˜¨ë‹¤. ì´ ê²½ìš° Apollo Federationì€ êµ‰ì¥íˆ ì¢‹ì€ í•´ê²°ì±…ì´ ëœë‹¤. ì´ë¯¸ Netflixì—ì„œë„ ë™ì¼í•œ ê³ ë¯¼ì„ í•˜ì˜€ìœ¼ë©°, Netflixì˜ ê²½ìš° Monolith GraphQL ì„œë¹„ìŠ¤ë¥¼ MSAí™”í•˜ëŠ” ì‘ì—…ì„ ì§„í–‰í•˜ë©´ì„œ Apollo Federationê³¼ ê¸´ë°€í•˜ê²Œ ì‘ì—…ì„ í•˜ì˜€ìœ¼ë©° ì§ì ‘ì ìœ¼ë¡œë„ ê¸°ì—¬ë¥¼ í–ˆë‹¤. ìš°ë¦¬ë„ ì²˜ìŒ Apollo Federationì„ ê²€í† í•  ë•Œ ì˜ˆìƒë˜ëŠ” ì—¬ëŸ¬ ë¬¸ì œì ë“¤ì´ ìˆì—ˆëŠ”ë°, ê·¸ ë¬¸ì œë“¤ì— ëŒ€í•´ì„œ í˜„ì¬ê¹Œì§€ëŠ” ëª¨ë‘ í•´ê²°ë°©ë²•ì´ ì¡´ì¬í•˜ì˜€ë‹¤. ì´ë¯¸ Netflixì—ì„œë„ ë™ì¼í•œ ê³ ë¯¼ì„ í•˜ì˜€ìœ¼ë©°, ê·¸ê²ƒì„ í•´ê²°í•˜ê¸° ìœ„í•´ì„œ ë§ì€ ê¸°ì—¬ë¥¼ í•œ ê²ƒìœ¼ë¡œ ì´í•´ëœë‹¤.

As the size of the service grows, there is a difficult time to work with one large GraphQL service. In this case, Apollo Federation is a very good solution. Netflix already had the same concern, and Netflix worked closely with Apollo Federation and directly contributed to the process of turning MSA from the Monolith GraphQL service. We also had a number of expected problems when we first reviewed Apollo Federation, and so far, there have been solutions to all of them. It is understood that Netflix has already made the same concern, and has contributed a lot to solve it.

### References

- [https://moonsupport.oopy.io/post/14](https://moonsupport.oopy.io/post/14)
- [https://brunch.co.kr/@fifthsage/19](https://brunch.co.kr/@fifthsage/19)
- [https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2](https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-1-ae3557c187e2)
- [https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-2-bbe71aaec44a](https://netflixtechblog.com/how-netflix-scales-its-api-with-graphql-federation-part-2-bbe71aaec44a)
- [https://youtu.be/QrEOvHdH2Cg](https://youtu.be/QrEOvHdH2Cg)
- [https://www.apollographql.com/docs/federation](https://www.apollographql.com/docs/federation/)

### Tags

#GraphQL #ApolloFederation #APIGateway #MSA #Subgraph